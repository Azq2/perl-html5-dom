=encoding utf8

=head1 NAME

HTML5::DOM - Super fast html5 DOM library with css selectors (based on Modest/MyHTML)

=for html <a href="https://travis-ci.org/Azq2/perl-html5-dom"><img src="https://travis-ci.org/Azq2/perl-html5-dom.svg?branch=master"></a>

=head1 SYNOPSIS

=head1 DESCRIPTION

L<HTML5::DOM> is a fast HTML5 parser and DOM manipulatin library with CSS4 selector, fully conformant with the HTML5 specification.

It based on  L<https://github.com/lexborisov/Modest> as selector engine and L<https://github.com/lexborisov/myhtml> as HTML5 parser. 

=head1 HTML5::DOM

HTML5 parser object.

=head2 new

 # with default options
 my $parser = HTML5::DOM->new;
 
 # override some options, if you need
 my $parser = HTML5::DOM->new({
    threads             => 2,
    async               => 0, 
    ignore_whitespace   => 0, 
    ignore_doctype      => 0, 
    scripts             => 0, 
    encoding            => "auto", 
    default_encoding    => "UTF-8", 
    encoding_use_meta   => 1, 
    encoding_use_bom    => 1, 
 });

Creates new parser object with options. See L<"PARSER OPTIONS"> for details. 

=head3 parse

 my $html = '<div>Hello world!</div>';
 
 # parsing with options defined in HTML5::DOM->new
 my $tree = $parser->parse($html);
 
 # parsing with custom options (extends options defined in HTML5::DOM->new)
 my $tree = $parser->parse($html, {
     scripts     => 0, 
 });

Parse html string and return L<HTML::DOM::Tree|/"HTML::DOM::Tree"> object.

=head3 parseChunkStart

 # start chunked parsing with options defined in HTML5::DOM->new
 # call parseChunkStart without options is useless, 
 # because first call of parseChunk automatically call parseChunkStart. 
 $parser->parseChunkStart();
 
 # start chunked parsing with custom options (extends options defined in HTML5::DOM->new)
 $parser->parseChunkStart({
    scripts     => 0, 
 });

Init chunked parsing. See L<"PARSER OPTIONS"> for details. 

=head3 parseChunk

 $parser->parseChunkStart()->parseChunk('<')->parseChunk('di')->parseChunk('v>');

Parse chunk of html stream.

=head3 parseChunkEnd

 # start some chunked parsing
 $parser->parseChunk('<')->parseChunk('di')->parseChunk('v>');
 
 # end parsing and get tree
 my $tree = $parser->parseChunkEnd();

Completes chunked parsing and return L<HTML::DOM::Tree|/"HTML::DOM::Tree"> object.



=head1 HTML5::DOM::Tree

DOM tree object.

=head3 createElement

 # create new node with tag "div"
 my $node = $tree->createElement("div");
 
 # create new node with tag "g" with namespace "svg"
 my $node = $tree->createElement("div", "svg");

Create new L<HTML5::DOM::Element|/"HTML5::DOM::Element"> with specified tag and namespace.

=head3 createComment

 # create new comment
 my $node = $tree->createComment("ololo");
 
 print $node->html; # <!-- ololo -->

Create new L<HTML5::DOM::Comment|/"HTML5::DOM::Comment"> with specified value.

=head3 createTextNode

 # create new text node
 my $node = $tree->createTextNode("ololo ololo i am driver ufo >>>");
 
 print $node->html; # ololo ololo i am driver ufo &gt;&gt;&gt;

Create new L<HTML5::DOM::Text|/"HTML5::DOM::Text"> with specified value.

=head3 parseFragment

 my $fragment = $tree->parseFragment($html, $context = 'div', $context_ns = 'html', $options = {});

Parse fragment html and create new L<HTML5::DOM::Fragment|/"HTML5::DOM::Fragment">.
For more details about fragments: L<https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments>

 # simple create new fragment
 my $node = $tree->parseFragment("some <b>bold</b> and <i>italic</i> text");

 # create new fragment node with custom context tag/namespace and options
 my $node = $tree->parseFragment("some <b>bold</b> and <i>italic</i> text", "div", "html", {
    # some options override
    encoding => "windows-1251"
 });
 
 print $node->html; # some <b>bold</b> and <i>italic</i> text

See L<"PARSER OPTIONS"> for details. 

=head3 document

 my $node = $tree->document;

Return L<HTML5::DOM::Document|/"HTML5::DOM::Document"> node of current tree;

=head3 root

 my $node = $tree->root;

Return root node of current tree. (always <html>)

=head3 head

 my $node = $tree->head;

Return <head> node of current tree. 

=head3 body

 my $node = $tree->body;

Return <body> node of current tree. 

=head3 at

=head3 querySelector

 my $node = $tree->at($selector);
 my $node = $tree->querySelector($selector); # alias

Find one element node in tree using L<CSS Selectors Level 4|https://www.w3.org/TR/selectors-4/>

Return node, or undef if not find.

 my $tree = HTML5::DOM->new->parse('<div class="red">red</div><div class="blue">blue</div>')
 my $node = $tree->at('body > div.red');
 print $node->html; # <div class="red">red</div>

=head3 find

=head3 querySelectorAll

 my $collection = $tree->find($selector);
 my $collection = $tree->querySelectorAll($selector); # alias

Find all element nodes in tree using L<CSS Selectors Level 4|https://www.w3.org/TR/selectors-4/>

Return L<HTML5::DOM::Collection|/"HTML5::DOM::Collection">.

 my $tree = HTML5::DOM->new->parse('<div class="red">red</div><div class="blue">blue</div>')
 my $collection = $tree->at('body > div.red, body > div.blue');
 print $collection->[0]->html; # <div class="red">red</div>
 print $collection->[1]->html; # <div class="red">blue</div>

=head3 findTag

=head3 getElementsByTagName

 my $collection = $tree->findTag($tag);
 my $collection = $tree->getElementsByTagName($tag); # alias

Find all element nodes in tree with specified tag name.

Return L<HTML5::DOM::Collection|/"HTML5::DOM::Collection">.

 my $tree = HTML5::DOM->new->parse('<div class="red">red</div><div class="blue">blue</div>')
 my $collection = $tree->findTag('div');
 print $collection->[0]->html; # <div class="red">red</div>
 print $collection->[1]->html; # <div class="red">blue</div>

=head3 findClass

=head3 getElementsByClassName

 my $collection = $tree->findClass($class);
 my $collection = $tree->getElementsByClassName($class); # alias

Find all element nodes in tree with specified class name.
This is more fast equivalent to [class~="value"] selector.

Return L<HTML5::DOM::Collection|/"HTML5::DOM::Collection">.

 my $tree = HTML5::DOM->new
    ->parse('<div class="red color">red</div><div class="blue color">blue</div>');
 my $collection = $tree->findClass('color');
 print $collection->[0]->html; # <div class="red color">red</div>
 print $collection->[1]->html; # <div class="red color">blue</div>

=head3 findAttr

=head3 getElementByAttribute
 
 # Find all elements with attribute
 my $collection = $tree->findAttr($attribute);
 my $collection = $tree->getElementByAttribute($attribute); # alias
 
 # Find all elements with attribute and mathcing value
 my $collection = $tree->findAttr($attribute, $value, $case = 0, $cmp = '=');
 my $collection = $tree->getElementByAttribute($attribute, $value, $case = 0, $cmp = '='); # alias

Find all element nodes in tree with specified attribute and optional matching value.

Return L<HTML5::DOM::Collection|/"HTML5::DOM::Collection">.

 my $tree = HTML5::DOM->new
    ->parse('<div class="red color">red</div><div class="blue color">blue</div>');
 my $collection = $tree->findAttr('class', 'CoLoR', 1, '~');
 print $collection->[0]->html; # <div class="red color">red</div>
 print $collection->[1]->html; # <div class="red color">blue</div>
 
CSS selector analogs:
 
 # [$attribute=$value]
 my $collection = $tree->findAttr($attribute, $value, 0, '=');
 
 # [$attribute=$value i]
 my $collection = $tree->findAttr($attribute, $value, 1, '=');
 
 # [$attribute~=$value]
 my $collection = $tree->findAttr($attribute, $value, 0, '~');
 
 # [$attribute|=$value]
 my $collection = $tree->findAttr($attribute, $value, 0, '|');
 
 # [$attribute*=$value]
 my $collection = $tree->findAttr($attribute, $value, 0, '*');

=head3 encoding

=head3 encodingId

 print "encoding: ".$tree->encoding."\n"; # UTF-8
 print "encodingId: ".$tree->encodingId."\n"; # 0

Return current tree encoding. See L<"ENCODINGS"> for details. 

=head3 tag2id

 print "tag id: ".HTML5::DOM::TAG_A."\n"; # tag id: 4
 print "tag id: ".$tree->tag2id("a")."\n"; # tag id: 4

Convert tag name to id. Return 0 (HTML5::DOM::TAG__UNDEF), if tag not exists in tree.
See L<"CONSTANTS"> for tag constants list. 

=head3 id2tag

 print "tag name: ".$tree->id2tag(4)."\n"; # tag name: a
 print "tag name: ".$tree->id2tag(HTML5::DOM::TAG_A)."\n"; # tag name: a

Convert tag id to name. Return undef, if tag id not exists in tree.
See L<"CONSTANTS"> for tag constants list. 

=head3 namespace2id

 print "ns id: ".HTML5::DOM::NS_HTML."\n"; # ns id: 1
 print "ns id: ".$tree->namespace2id("html")."\n"; # ns id: 1

Convert namespace name to id. Return 0 (HTML5::DOM::NS_UNDEF), if namespace not exists in tree.
See L<"CONSTANTS"> for namespace constants list. 

=head3 id2namespace

 print "ns name: ".$tree->id2namespace(1)."\n"; # ns name: html
 print "ns name: ".$tree->id2namespace(HTML5::DOM::NS_HTML)."\n"; # ns name: html

Convert namespace id to name. Return undef, if namespace id not exists.
See L<"CONSTANTS"> for namespace constants list. 

=head3 wait

 my $parser = HTML5::DOM->new({async => 1});
 my $tree = $parser->parse($some_big_html_file);
 # ...some your work...
 $tree->wait; # wait before parsing threads done

Blocking wait for tree parsing done. Only for async mode.

=head3 parsed

 my $parser = HTML5::DOM->new({async => 1});
 my $tree = $parser->parse($some_big_html_file);
 # ...some your work...
 while (!$tree->parsed); # wait before parsing threads done

Non-blocking way for check if tree parsing done. Only for async mode.

=head3 parser

 my $parser = $tree->parser;

Return parent L<HTML5::DOM|/"HTML5::DOM">.



=head1 HTML5::DOM::Node

DOM node object.

=head3 tag

=head3 nodeName

 my $tag_name = $node->tag;
 my $tag_name = $node->nodeName; # alias

Return node tag name (eg. div or span)

 $node->tag($tag);
 $node->nodeName($tag); # alias

Set new node tag name. Allow only for L<HTML5::DOM::Element|/"HTML5::DOM::Element"> nodes.

 print $node->html; # <div></div>
 $node->tag('span');
 print $node->html; # <span></span>
 print $node->tag; # span

=head3 tagId

 my $tag_id = $node->tagId;

Return node tag id. See L<"CONSTANTS"> for tag constants list.

 $node->tagId($tag_id);

Set new node tag id. Allow only for L<HTML5::DOM::Element|/"HTML5::DOM::Element"> nodes.

 print $node->html; # <div></div>
 $node->tagId(HTML5::DOM::TAG_SPAN);
 print $node->html; # <span></span>
 print $node->tagId; # 117

=head3 namespace

 my $tag_ns = $node->namespace;

Return node namespace (eg. html or svg)

 $node->namespace($namespace);

Set new node namespace name. Allow only for L<HTML5::DOM::Element|/"HTML5::DOM::Element"> nodes.

 print $node->namespace; # html
 $node->namespace('svg');
 print $node->namespace; # svg

=head3 namespaceId

 my $tag_ns_id = $node->namespaceId;

Return node namespace id. See L<"CONSTANTS"> for tag constants list.

 $node->namespaceId($tag_id);

Set new node namespace by id. Allow only for L<HTML5::DOM::Element|/"HTML5::DOM::Element"> nodes.

 print $node->namespace; # html
 $node->namespaceId(HTML5::DOM::NS_SVG);
 print $node->namespaceId; # 3
 print $node->namespace; # svg

=head3 tree

 my $tree = $node->tree;
 
Return parent tree object.

=head3 nodeType

 my $type = $node->nodeType;
 
Return node type. All types:

 HTML5::DOM::ELEMENT_NODE                   => 1, 
 HTML5::DOM::ATTRIBUTE_NODE                 => 2,   # not supported
 HTML5::DOM::TEXT_NODE                      => 3, 
 HTML5::DOM::CDATA_SECTION_NODE             => 4,   # not supported
 HTML5::DOM::ENTITY_REFERENCE_NODE          => 5,   # not supported
 HTML5::DOM::ENTITY_NODE                    => 6,   # not supported
 HTML5::DOM::PROCESSING_INSTRUCTION_NODE    => 7,   # not supported
 HTML5::DOM::COMMENT_NODE                   => 8, 
 HTML5::DOM::DOCUMENT_NODE                  => 9, 
 HTML5::DOM::DOCUMENT_TYPE_NODE             => 10, 
 HTML5::DOM::DOCUMENT_FRAGMENT_NODE         => 11, 
 HTML5::DOM::NOTATION_NODE                  => 12   # not supported

Compatible with: L<https://developer.mozilla.org/ru/docs/Web/API/Node/nodeType>

=head3 next

=head3 nextElementSibling

 my $node2 = $node->next;
 my $node2 = $node->nextElementSibling; # alias

Return next sibling element node
 
 my $parser = HTML5::DOM->new->parse('
    <ul>
        <li>Linux</li>
        <!-- comment -->
        <li>OSX</li>
        <li>Windows</li>
    </ul>
 ');
 my $li = $parser->at('ul li');
 print $li->text;               # Linux
 print $li->next->text;         # OSX
 print $li->next->next->text;   # Windows

=head3 prev

=head3 previousElementSibling

 my $node2 = $node->prev;
 my $node2 = $node->previousElementSibling; # alias

Return previous sibling element node
 
 my $parser = HTML5::DOM->new->parse('
    <ul>
        <li>Linux</li>
        <!-- comment -->
        <li>OSX</li>
        <li class="win">Windows</li>
    </ul>
 ');
 my $li = $parser->at('ul li.win');
 print $li->text;               # Windows
 print $li->prev->text;         # OSX
 print $li->prev->prev->text;   # Linux

=head3 nextNode

=head3 nextSibling

 my $node2 = $node->nextNode;
 my $node2 = $node->nextSibling; # alias

Return next sibling node
 
 my $parser = HTML5::DOM->new->parse('
    <ul>
        <li>Linux</li>
        <!-- comment -->
        <li>OSX</li>
        <li>Windows</li>
    </ul>
 ');
 my $li = $parser->at('ul li');
 print $li->text;                       # Linux
 print $li->nextNode->text;             # <!-- comment -->
 print $li->nextNode->nextNode->text;   # OSX

=head3 prevNode

=head3 previousSibling

 my $node2 = $node->prevNode;
 my $node2 = $node->previousSibling; # alias

Return previous sibling node
 
 my $parser = HTML5::DOM->new->parse('
    <ul>
        <li>Linux</li>
        <!-- comment -->
        <li>OSX</li>
        <li class="win">Windows</li>
    </ul>
 ');
 my $li = $parser->at('ul li.win');
 print $li->text;                       # Windows
 print $li->prevNode->text;             # OSX
 print $li->prevNode->prevNode->text;   # <!-- comment -->

=head3 first

=head3 firstElementChild

 my $node2 = $node->first;
 my $node2 = $node->firstElementChild; # alias

Return first children element
 
 my $parser = HTML5::DOM->new->parse('
    <ul>
        <!-- comment -->
        <li>Linux</li>
        <li>OSX</li>
        <li class="win">Windows</li>
    </ul>
 ');
 my $ul = $parser->at('ul');
 print $ul->first->text; # Linux

=head3 last

=head3 lastElementChild

 my $node2 = $node->last;
 my $node2 = $node->lastElementChild; # alias

Return last children element
 
 my $parser = HTML5::DOM->new->parse('
    <ul>
        <li>Linux</li>
        <li>OSX</li>
        <li class="win">Windows</li>
        <!-- comment -->
    </ul>
 ');
 my $ul = $parser->at('ul');
 print $ul->last->text; # Windows

=head3 firstNode

=head3 firstChild

 my $node2 = $node->firstNode;
 my $node2 = $node->firstChild; # alias

Return first children node
 
 my $parser = HTML5::DOM->new->parse('
    <ul>
        <!-- comment -->
        <li>Linux</li>
        <li>OSX</li>
        <li class="win">Windows</li>
    </ul>
 ');
 my $ul = $parser->at('ul');
 print $ul->firstNode->html; # <!-- comment -->

=head3 lastNode

=head3 lastChild

 my $node2 = $node->lastNode;
 my $node2 = $node->lastChild; # alias

Return last children node
 
 my $parser = HTML5::DOM->new->parse('
    <ul>
        <li>Linux</li>
        <li>OSX</li>
        <li class="win">Windows</li>
        <!-- comment -->
    </ul>
 ');
 my $ul = $parser->at('ul');
 print $ul->lastNode->html; # <!-- comment -->

=head1 PARSER OPTIONS

Options for L<HTML5::DOM::new>, L<HTML5::DOM::parse>, L<HTML5::DOM::new>, L<HTML5::DOM::Node::parseFragment>

=head4 threads

Threads count, if 0 - parsing in single mode without threads (default 2)

=head4 async

If async 0 (default), then some parse functions L<HTML5::DOM::Node::parseFragment|/parseFragment>, L<HTML5::DOM::parse|/parse>, L<HTML5::DOM::parseChunkEnd|/parseChunkEnd> waiting for parsing done.

If async 1, you must manualy call L<HTML5::DOM::Node::wait|/wait> and L<HTML5::DOM::Tree::wait|/wait> for waiting parsing of node or tree done or 
L<HTML5::DOM::Node::parsed|/parsed>, L<HTML5::DOM::Node::parsed|/parsed> to non-blocking determine parsing done.

This options affects only if threads > 0

=head4 ignore_whitespace

Ignore whitespace tokens (default 0)

=head4 ignore_doctype

Do not parse DOCTYPE (default 0)

=head4 scripts

If 1 - <noscript> contents parsed to single text node (default)

If 0 - <noscript> contents parsed to child nodes

=head4 encoding

Encoding of input HTML, if auto - library can tree to automaticaly determine encoding. (default "auto")

=head4 default_encoding

Default encoding, this affects only if encoding set to "auto" and encoding not determined. (default "UTF-8")

=head4 encoding_use_meta

Allow use <meta> tags to determine input HTML encoding. (default 1)

=head4 encoding_use_bom

Allow use detecding BOM to determine input HTML encoding. (default 1)
